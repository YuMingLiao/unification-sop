{-# language DeriveGeneric, DeriveAnyClass, PatternSynonyms, GADTs #-}

{-|

  Use unification-sop if you want a mechanism to generically derive prolog-style
  unification for your datatypes, with minimal boilerplate.

  When talking of unification, the usual implementation is the
  <http://hackage.haskell.org/package/unification-fd unification-fd> package.
  However that package has two major shortcomings in my opinion:

  * Your datatype has to be in the form of the fixpoint of a functor.

  * It's not immediately clear how to use it, the typeclasses and the types
    involved, and the lack of documentation can be daunting.

  In this package we construct a different mechanism for unification which is
  strictly more expressive, letting us work with datatypes that are not in the
  fixpoint form, and simpler, requiring only an additional datatype, and that
  does not perform abysmally worse (since the core algorithm is the same). That
  said, try to use `unification-fd` if you want unification for typechecking
  (which is the main use-case of that package) because it is surely more stable
  and it still has more optimization than this one (like, path-compression).
-}

module Generic.Unification.Tutorial
  ( -- * Introduction
    -- $introduction
    Foo(..)
    -- $derivingInstances

    -- * Examples of Terms
    -- $termExamples
  , ex1, ex2, ex3, ex4
    -- * Smart constructors
    -- $smartConstructors

    -- * Unification
    -- $unification1
  , exU1, exU2, exU3
    -- $unification2

    -- * Further examples
    -- $furtherExamples
  ) where

import Control.Monad.Identity
import Generics.SOP
import qualified GHC.Generics as GHC

import Generic.Unification.Term
import Generic.Unification.Unification
import Generic.Unification.Substitution
import Generic.Unification.Hinze



-- $introduction
-- Let's consider a datatype we will use as an example through this tutorial:

data Foo = FooI Int | FooS String Foo
    deriving ( Show, Eq, GHC.Generic, Generic, HasDatatypeInfo )

-- $derivingInstances
--
-- To use this library you need to deriving the generic instances. You
-- can do that via:
--
-- > deriving (GHC.Generic, Generic, HasDatatypeInfo)
--
-- provided you have the `DeriveGeneric` and `DeriveAnyClass` extensions enabled
-- (Generic and HasDatatypeInfo come from
-- [generic-sop](http://hackage.haskell.org/package/generics-sop-0.4.0.1)).
-- That's all the boilerplate you need!

-- $termExamples
--
-- Taking inspiration from prolog, we would like to express terms that are of
-- type Foo, but can have (typed) logical variables as subterms. In this
-- library, that's the role of the 'Term' datatype. In this case a 'Term' 'Foo' is
-- a 'Foo' that can have logical variables as subterms.
--
-- Let's see some examples, where I also give a prolog translation (haskell
-- constructors are seen as prolog [clean
-- representations](https://www.metalevel.at/prolog/data#clean)). Keep in mind
-- that the show instances that display these result are automatically generated
-- to be consistent with the smart constructors I'll talk about later.

-- | A logical variable of type `Foo`, equivalent to /X/ in prolog.
--
-- >>> ex1
-- Var 1
ex1 :: Term Foo
ex1 = Var 1

-- | A completely determined term, in fact expressing `FooI 3` as a `Term Foo`.
-- Equivalent to /fooI(3)/ in prolog.
--
-- >>> ex2
-- Con (FooI 3)
ex2 :: Term Foo
ex2 = Con (FooI 3)

-- | A term which uses the FooI constructor, but the integer inside is replaced
-- with a logical variable, equivalent to /fooI(X)/ in prolog.
--
-- >>> ex3
-- fooI (Var 1)
ex3 :: Term Foo
ex3 = Rec . SOP . Z $ (Var 1) :* Nil

-- | A term which mixes both defined values and variables, equivalent to /fooS("hi", X)/ in prolog.
--
-- >>> ex4
-- fooS (Con "hi") (Var 1)
ex4 :: Term Foo
ex4 = Rec . SOP . S . Z $ (Con "hi") :* (Var 1) :* Nil

-- $smartConstructors
--
-- To make easier working with terms, I propose the usage of smart constructors.
-- For example, for our Foo datatype, we could define:
--
-- > fooS :: Term String -> Term Foo -> Term Foo
-- > fooS ts tf = Rec . SOP . S . Z $ ts :* tf :* Nil
--
-- > fooI :: Term Int -> Term Foo
-- > fooI ti = Rec . SOP . Z $ ti :* Nil
--
-- This constructs could be completely generated by the library (via generics or
-- TH), but in this iteration of the library they have to be generated by the
-- user. It is worth noting that the show instances I generated are geared
-- towards this use-case, and that is automatic. With there smart constructors
-- defined, we can actually write previous examples exactly the way they are
-- shown by our show instance.
--
-- Depending on your needs, you could also define these as bidirectional
-- patterns instead, enabling PatternSynonyms and writing:
--
-- > pattern TFooI :: Term Int -> Term Foo
-- > pattern TFooI t = Rec (SOP (Z (t :* Nil)))
--
-- > pattern TFooR :: Term String -> Term Foo -> Term Foo
-- > pattern TFooR ti tf = Rec (SOP (S (Z (ti :* tf :* Nil))))

fooS :: Term String -> Term Foo -> Term Foo
fooS ts tf = Rec . SOP . S . Z $ ts :* tf :* Nil

fooI :: Term Int -> Term Foo
fooI ti = Rec . SOP . Z $ ti :* Nil

pattern TFooI :: Term Int -> Term Foo
pattern TFooI t = Rec (SOP (Z (t :* Nil)))

pattern TFooR :: Term String -> Term Foo -> Term Foo
pattern TFooR ti tf = Rec (SOP (S (Z (ti :* tf :* Nil))))


-- $unification1
--
-- Now let's have an example of a unification between two terms:

-- | Equivalent to /fooS(\"Hello\", fooS(X, fooI(Y)))/ in prolog.
--
-- >>> exU1
-- fooS (Con "Hello") (fooS (Var 1) (fooI (Var 1)))
exU1 :: Term Foo
exU1 = fooS (Con "Hello") (fooS (Var 1) (fooI (Var 1)))

-- | Equivalent to /fooS(X, fooS(\"World\", fooI(Y)))/ in prolog.
--
-- >>> exU2
-- fooS (Var 2) (fooS (Con "World") (fooI (Var 1)))
exU2 :: Term Foo
exU2 = fooS (Var 2) (fooS (Con "World") (fooI (Var 1)))

-- | Equivalent to /fooS(X, fooS(\"Earth\", fooI(Y)))/ in prolog.
--
-- >>> exU2
-- fooS (Var 2) (fooS (Con "World") (fooI (Var 1)))
exU3 :: Term Foo
exU3 = fooS (Var 2) (fooS (Con "Earth") (fooI (Var 1)))

-- $unification2
-- The result of unification can be Right and the substituted term, or Left and
-- an explanation of the error.
--
-- >>> :t unify exU1 exU2
-- unify exU1 exU2 :: Monad m => UnificationT m (Term Foo)
--
-- >>> runIdentity . evalUnificationT $ unify exU1 exU2
-- Right (fooS (Con "Hello") (fooS (Con "World") (fooI (Var 1))))
--
-- In this case we can see that the unification succeeded, leaving the Int-typed
-- variable alone.
--
-- >>> runIdentity . evalUnificationT $ unify exU2 exU3
-- Left IncompatibleUnification
--
-- In this case we can see that the two terms can't be unified.

-- $furtherExamples
--
-- If you want further inspiration, in the 'Generic.Unification.Hinze' module I
-- implemented a full typed prolog complete with the Cut construct, following
-- Hinze's paper on denotational semantic of a prolog interpreter. If you have
-- question don't hesitate to write them in the github issue tracker.

--------------------------------------------------------------------------------
-- More stuff, that I don't want yet to talk about
--------------------------------------------------------------------------------

-- Let's do an example with lists: I need the smart constructors
nil :: Term [a]
nil = Con []

cons :: Term a -> Term [a] -> Term [a]
cons t ts = Rec . SOP . S . Z $ t :* ts :* Nil

ex_list1_1, ex_list1_2, ex_list1_3 :: Term [Int]
ex_list1_1 = cons (Var 1)   (cons (Var 2) nil)
ex_list1_2 = cons (Var 2)   (cons (Var 1) nil)
ex_list1_3 = cons (Con 100) (cons (Var 3) nil)

-- >>> runUnification $ unifyVal ex_list1_1 ex_list1_2
-- (Right (: (Var 1) (: (Var 1) (Con []))),Substitution { Int -> [(1,Var 2),(2,Var 1)] })

-- >>> ex_list1_1 `unify` ex_list1_2 >>= (`unify` ex_list1_3)
-- Right (: (Con 100) (: (Con 100) (Con [])))

-- Let's see an example with an infinite solution, the prolog [a, X] = X

ex_list2_1, ex_list2_2, ex_list2_3 :: Term [Int]
ex_list2_1 = cons (Con 1) (Var 1)
ex_list2_2 = Var 1
ex_list2_3 = cons (Var 2) (cons (Var 3) (Var 4))

-- >>> runUnification (unifyVal ex_list2_1 ex_list2_2)
-- (Right (: (Con 1) (Var 1)),Substitution { [Int] -> [(1,: (Con 1) (Var 1))] })

-- >>> runUnification (unifyVal ex_list2_2 ex_list2_1)
-- (Right (: (Con 1) (Var 1)),Substitution { [Int] -> [(1,: (Con 1) (Var 1))] })

-- >>> unify ex_list2_1 ex_list2_2 >>= unify ex_list2_3
-- Right (: (Con 1) (: (Var 3) (Var 4)))
-- >>> unify ex_list2_1 ex_list2_3 >>= unify ex_list2_2
-- Right (: (Con 1) (: (Var 3) (Var 4)))
-- >>> unify ex_list2_2 ex_list2_3 >>= unify ex_list2_1
-- Right (: (Con 1) (: (Var 3) (Var 4)))

-- >>> runUnification $ unifyVal ex_list2_1 ex_list2_2 >>= unifyVal ex_list2_3
-- (Right (: (Con 1) (: (Con 1) (: (Con 1) (: (Con 1) (: (Con 1) (Var 1)))))),Substitution { [Int] -> [(1,: (Con 1) (Var 1)),(4,: (Con 1) (Var 1))], Int -> [(2,Con 1),(3,Con 1)] })
-- >>> runUnification $ unifyVal ex_list2_1 ex_list2_3 >>= unifyVal ex_list2_2
-- (Right (: (Con 1) (: (Con 1) (: (Var 3) (Var 4)))),Substitution { [Int] -> [(1,: (Var 3) (Var 4)),(4,: (Var 3) (Var 4))], Int -> [(2,Con 1),(3,Con 1)] })
-- >>> runUnification $ unifyVal ex_list2_2 ex_list2_3 >>= unifyVal ex_list2_1
-- (Right (: (Con 1) (: (Con 1) (: (Con 1) (: (Con 1) (: (Var 3) (Var 4)))))),Substitution { [Int] -> [(1,: (Var 2) (: (Var 3) (Var 4))),(4,: (Var 3) (Var 4))], Int -> [(2,Con 1),(3,Con 1)] })

--------------------------------------------------------------------------------
--- Potential problem: recursive datatypes
--------------------------------------------------------------------------------

data Bar1 = Bar1 Bar2 | Bar1Base
  deriving (Eq, Show, GHC.Generic, Generic, HasDatatypeInfo, Substitutable, Unifiable)
data Bar2 = Bar2 Bar1 | Bar2Base
  deriving (Eq, Show, GHC.Generic, Generic, HasDatatypeInfo, Substitutable, Unifiable)

pattern TBar1 :: Term Bar2 -> Term Bar1
pattern TBar1 t = Rec (SOP (Z (t :* Nil)))
pattern TBar1Base :: Term Bar1
pattern TBar1Base = Rec (SOP (S (Z Nil)))
pattern TBar2 :: Term Bar1 -> Term Bar2
pattern TBar2 t = Rec (SOP (Z (t :* Nil)))
pattern TBar2Base :: Term Bar2
pattern TBar2Base = Rec (SOP (S (Z Nil)))

exBar1 = TBar2 (Var 1)
exBar2 = TBar2 (TBar1 (TBar2 (Var 1)))

test :: Logic (Term Bar2)
test = exBar1 === exBar2

-- >>> evalLogic test
-- [bar2 (bar1 (bar2 (Var 1)))]
