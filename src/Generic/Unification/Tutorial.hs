{-# language DeriveGeneric, DeriveAnyClass, PatternSynonyms, GADTs #-}

{-|

  Use unification-sop if you want a mechanism to derive unification for your
  datatype in a generic way. When talking of unification, the reference
  implementation is the <http://hackage.haskell.org/package/unification-fd
  unification-fd> package. However that package has two major shortcomings in my
  opinion:

  * Your datatype has to be in the form of the fixpoint of a functor.

  * It's not immediately clear how to use it, and the documentation can be
    daunting.

   that said, use that package if you are using unification for typechecking
   (which is the main use-case of that package) because it is surely more stable.

  In this package we will see how to construct a different mechanism for
  unification which is strictly more expressive, letting us work with datatypes
  that are not in the fixpoint form.
-}

module Generic.Unification.Tutorial
  ( -- * Introduction
    -- $introduction
    Foo(..)
    -- $derivingInstances
  , ex1, ex2
    -- * Smart constructors
    -- $smartConstructors

    -- * Unification
    -- $unification

    -- * Discussion
    -- $discussion
  ) where

import Generic.Unification.Term
import Generic.Unification.Unification
import Generic.Unification.Substitution
import Generic.Unification.Hinze
import qualified GHC.Generics as GHC
import Generics.SOP

-- $introduction
-- So, let's say you have a datatype, and you want to unify two terms:

-- | This is an example we'll use throughout the package
data Foo = FooI Int | FooS String Foo
    deriving ( Show, Eq, GHC.Generic, Generic, HasDatatypeInfo )

-- $derivingInstances
-- The first step is deriving the generic instances. You can do that via
--
-- > deriving (GHC.Generic, Generic, HasDatatypeInfo)
--
-- provided you have the `DeriveGeneric` and `DeriveAnyClass` extensions enabled
-- (Generic and HasDatatypeInfo come from the generic-sop package).
--
-- And now, as your type is a tree which has only primitive types at the leaves,
-- you get to construct generic terms.
--
-- A few examples of terms constructed in this way, with the prolog translation
--
-- > ex1 :: Term Foo
-- > ex1 = Var 1           -- X
--
-- > ex2 :: Term Foo
-- > ex2 = Con (FooI 3)          -- fooI 3
--
--
-- >>> ex1 :: Term Foo
-- Var 1
-- 
-- >>> ex4 :: Term Foo
-- fooS (Con "ciao") (Con (FooI 2))


ex1, ex2, ex3, ex4 :: Term Foo
ex1 = Var 1
ex2 = Con (FooI 3)
ex3 = Rec . SOP . Z $ (Var 1) :* Nil
ex4 = Rec . SOP . S . Z $ (Con "ciao") :* (Con $ FooI 2) :* Nil

-- $smartConstructors
--
-- To make more easy working with terms, we propose the usage of smart
-- constructors. For example, for our Foo datatype, we could define:
--
-- > fooS :: Term String -> Term Foo -> Term Foo
-- > fooS ts tf = Rec . SOP . S . Z $ ts :* tf :* Nil
--
-- > fooI :: Term Int -> Term Foo
-- > fooI ti = Rec . SOP . Z $ ti :* Nil
--
-- This constructs could be completely generated by the library (via generics or
-- TH), but in this iteration of the library they have to be generated by the
-- user. It is worth noting that the show instances I generated are geared
-- towards this use-case, and that is automatic.
--
-- With there smart constructors defined, we can revisit previous examples:
--
-- > ex3', ex4', ex5', ex5'var, ex5'var2 :: Term Foo
-- > ex3' = fooI (Var 1)
-- > ex4' = fooS (Con "ciao") (Con $ FooI 2)
-- > ex5' = fooS (Con "ciao") (fooS (Var 1) (Con $ FooI 2))
-- > ex5'var = fooS (Var 2) (fooS (Con "hey") (Con $ FooI 2))
-- > ex5'var2 = fooS (Var 1) (fooS (Con "hey") (Con $ FooI 2))

fooS :: Term String -> Term Foo -> Term Foo
fooS ts tf = Rec . SOP . S . Z $ ts :* tf :* Nil

fooI :: Term Int -> Term Foo
fooI ti = Rec . SOP . Z $ ti :* Nil

-- $unification
--
-- Now let's have some examples of unification:
--
-- >>> unify (fooS (Var 2) (fooS (Con "hey") (Con $ FooI 2))) (fooS (Var 1) (fooS (Con "hey") (Con $ FooI 2)))
-- Right (fooS (Var 1) (fooS (Con "hey") (Con (FooI 2))))
--
-- Which is `fooS X (fooS "hey" (fooI 2)) == fooS Y (fooS "hey" (fooI 2))` in
-- prolog-like notation. Take a better example here.
-- 
-- The result of unification can be Right and the substituted term, or Left and
-- an explanation of the error.

-- $discussion
-- Here the differences with unification-fd
-- 
-- TODO Move the examples

-- >>> unify ex5' ex5'
-- Right (fooS (Con "ciao") (fooS (Var 1) (Con (FooI 2))))
-- >>> evalUnification $ unifyVal ex5' ex5'var
-- Right (fooS (Con "ciao") (fooS (Con "hey") (Con (FooI 2))))
-- >>> evalUnification $ unifyVal ex5' ex5'var2
-- Left IncompatibleUnification

-- Let's do an example with lists: I need the smart constructors
nil :: Term [a]
nil = Con []

cons :: Term a -> Term [a] -> Term [a]
cons t ts = Rec . SOP . S . Z $ t :* ts :* Nil

ex_list1_1, ex_list1_2, ex_list1_3 :: Term [Int]
ex_list1_1 = cons (Var 1)   (cons (Var 2) nil)
ex_list1_2 = cons (Var 2)   (cons (Var 1) nil)
ex_list1_3 = cons (Con 100) (cons (Var 3) nil)

-- >>> runUnification $ unifyVal ex_list1_1 ex_list1_2
-- (Right (: (Var 1) (: (Var 1) (Con []))),Substitution { Int -> [(1,Var 2),(2,Var 1)] })

-- >>> ex_list1_1 `unify` ex_list1_2 >>= (`unify` ex_list1_3)
-- Right (: (Con 100) (: (Con 100) (Con [])))

-- Let's see an example with an infinite solution, the prolog [a, X] = X

ex_list2_1, ex_list2_2, ex_list2_3 :: Term [Int]
ex_list2_1 = cons (Con 1) (Var 1)
ex_list2_2 = Var 1
ex_list2_3 = cons (Var 2) (cons (Var 3) (Var 4))

-- >>> runUnification (unifyVal ex_list2_1 ex_list2_2)
-- (Right (: (Con 1) (Var 1)),Substitution { [Int] -> [(1,: (Con 1) (Var 1))] })

-- >>> runUnification (unifyVal ex_list2_2 ex_list2_1)
-- (Right (: (Con 1) (Var 1)),Substitution { [Int] -> [(1,: (Con 1) (Var 1))] })

-- >>> unify ex_list2_1 ex_list2_2 >>= unify ex_list2_3
-- Right (: (Con 1) (: (Var 3) (Var 4)))
-- >>> unify ex_list2_1 ex_list2_3 >>= unify ex_list2_2
-- Right (: (Con 1) (: (Var 3) (Var 4)))
-- >>> unify ex_list2_2 ex_list2_3 >>= unify ex_list2_1
-- Right (: (Con 1) (: (Var 3) (Var 4)))

-- >>> runUnification $ unifyVal ex_list2_1 ex_list2_2 >>= unifyVal ex_list2_3
-- (Right (: (Con 1) (: (Con 1) (: (Con 1) (: (Con 1) (: (Con 1) (Var 1)))))),Substitution { [Int] -> [(1,: (Con 1) (Var 1)),(4,: (Con 1) (Var 1))], Int -> [(2,Con 1),(3,Con 1)] })
-- >>> runUnification $ unifyVal ex_list2_1 ex_list2_3 >>= unifyVal ex_list2_2
-- (Right (: (Con 1) (: (Con 1) (: (Var 3) (Var 4)))),Substitution { [Int] -> [(1,: (Var 3) (Var 4)),(4,: (Var 3) (Var 4))], Int -> [(2,Con 1),(3,Con 1)] })
-- >>> runUnification $ unifyVal ex_list2_2 ex_list2_3 >>= unifyVal ex_list2_1
-- (Right (: (Con 1) (: (Con 1) (: (Con 1) (: (Con 1) (: (Var 3) (Var 4)))))),Substitution { [Int] -> [(1,: (Var 2) (: (Var 3) (Var 4))),(4,: (Var 3) (Var 4))], Int -> [(2,Con 1),(3,Con 1)] })

--------------------------------------------------------------------------------
--- Potential problem: recursive datatypes
--------------------------------------------------------------------------------

data Bar1 = Bar1 Bar2 | Bar1Base
  deriving (Eq, Show, GHC.Generic, Generic, HasDatatypeInfo, Substitutable, Unifiable)
data Bar2 = Bar2 Bar1 | Bar2Base
  deriving (Eq, Show, GHC.Generic, Generic, HasDatatypeInfo, Substitutable, Unifiable)

pattern TBar1 :: Term Bar2 -> Term Bar1
pattern TBar1 t = Rec (SOP (Z (t :* Nil)))
pattern TBar1Base :: Term Bar1
pattern TBar1Base = Rec (SOP (S (Z Nil)))
pattern TBar2 :: Term Bar1 -> Term Bar2
pattern TBar2 t = Rec (SOP (Z (t :* Nil)))
pattern TBar2Base :: Term Bar2
pattern TBar2Base = Rec (SOP (S (Z Nil)))

exBar1 = TBar2 (Var 1)
exBar2 = TBar2 (TBar1 (TBar2 (Var 1)))

test :: Logic (Term Bar2)
test = exBar1 === exBar2

-- >>> evalLogic test
-- [bar2 (bar1 (bar2 (Var 1)))]
