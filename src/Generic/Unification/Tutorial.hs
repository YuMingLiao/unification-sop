{-# language DeriveGeneric #-}

{-|

  Use unification-sop if you want a mechanism to derive unification for
  datatype. When talking of unification, the reference implementation is the
  <http://hackage.haskell.org/package/unification-fd unification-fd> package.
  However that package has two major shortcomings in my opinion:

  * Your datatype has to be in the form of the fixpoint of a functor.

  * It's not immediately clear how to use it, and it has a documentation vacuum.

   that said, use that package if you are using unification for typechecking
   (which is the main use-case of that package) because it is surely more stable.

  In this package we will see how to construct our version of a (finish this)..

-}

module Generic.Unification.Tutorial
  ( -- * Introduction
    -- $introduction
    Foo(..)
    -- $derivingInstances
  , ex1, ex2
    -- * Smart constructors
    -- $smartConstructors

    -- * Unification
    -- $unification

    -- * Discussion
    -- $discussion
  ) where

import Generic.Unification.Term
import Generic.Unification.Unification
import qualified GHC.Generics as GHC
import Generics.SOP

-- $introduction
-- So, let's say you have a normal datatype, and you want to unify two terms:


-- | This is an example we'll use throughout the package
data Foo = FooI Int | FooS String Foo
    deriving ( Show, Eq, GHC.Generic )

instance Generic Foo
instance HasDatatypeInfo Foo

-- $derivingInstances
-- The first step is deriving the generic instance. You can do that via
--
-- > deriving (GHC.Generic)
--
-- then you have to declare the Generic and HasDatatypeInfo instances from the
-- generic-sop package:
--
-- > instance Generic Foo
-- > instance HasDatatypeInfo Foo
--
-- And now, as your type is a tree which has only primitive types at the leaves,
-- you get to construct generic terms.
--
-- A few examples of terms constructed in this way, with the prolog meaning
--
-- > ex1 :: Term Foo
-- > ex1 = Var 1           -- X
--
-- > ex2 :: Term Foo
-- > ex2 = Con (FooI 3)          -- fooI 3
--
--
-- >>> ex1 :: Term Foo
-- Var 1
-- 
-- >>> ex4 :: Term Foo
-- fooS (Con "ciao") (Con (FooI 2))


ex1, ex2, ex3, ex4 :: Term Foo
ex1 = Var 1

ex2 = Con (FooI 3)

ex3 = Rec . SOP . Z $ (Var 1) :* Nil

ex4 = Rec . SOP . S . Z $ (Con "ciao") :* (Con $ FooI 2) :* Nil

-- $smartConstructors
--
-- To make more easy working with terms, we propose the usage of smart
-- constructors. For example, for our Foo datatype, we could define:
--
-- > fooS :: Term String -> Term Foo -> Term Foo
-- > fooS ts tf = Rec . SOP . S . Z $ ts :* tf :* Nil
--
-- > fooI :: Term Int -> Term Foo
-- > fooI ti = Rec . SOP . Z $ ti :* Nil
--
-- This constructs could be completely generated by the library (via generics or
-- TH), but in this iteration of the library they have to be generated by the
-- user. It is worth noting that the show instances I generated are geared
-- towards this use-case, and that is automatic.
--
-- With there smart constructors defined, we can revisit previous examples:
--
-- > ex3', ex4', ex5', ex5'var, ex5'var2 :: Term Foo
-- > ex3' = fooI (Var 1)
-- > ex4' = fooS (Con "ciao") (Con $ FooI 2)
-- > ex5' = fooS (Con "ciao") (fooS (Var 1) (Con $ FooI 2))
-- > ex5'var = fooS (Var 2) (fooS (Con "hey") (Con $ FooI 2))
-- > ex5'var2 = fooS (Var 1) (fooS (Con "hey") (Con $ FooI 2))

fooS :: Term String -> Term Foo -> Term Foo
fooS ts tf = Rec . SOP . S . Z $ ts :* tf :* Nil

fooI :: Term Int -> Term Foo
fooI ti = Rec . SOP . Z $ ti :* Nil

-- $unification
--
-- Now some examples of unification
--
-- >>> unify (fooS (Var 2) (fooS (Con "hey") (Con $ FooI 2))) (fooS (Var 1) (fooS (Con "hey") (Con $ FooI 2)))
-- Right (fooS (Var 1) (fooS (Con "hey") (Con (FooI 2))))
--
-- Which is (fooS X (fooS "hey" (fooI 2))) == fooS Y (fooS "hey" (fooI 2)) in
-- prolog-like notation. Take a better example here.
-- 
-- Anyway the result of unification can be Right and the substituted term, or
-- Left and an explanation of the error.

-- $discussion
-- Here the differences with unification-fd